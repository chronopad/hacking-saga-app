from itertools import chain, combinations
from Crypto.Util.number import long_to_bytes
from math import prod

def all_subsets(arr):
    return list(chain.from_iterable(combinations(arr, r) for r in range(len(arr)+1)))

n = 139022567356530846822678730833487002880521153522696782360834242778968885142293685518313776346272689004952989636250600196482709056257654282705491770932585073021122150094317360916683586473802635503536260399443144552370842635710950296229966888012006522639932615654332430553478447923284731693206623140810921762409
e = 65537
c = 77170831332537446404028665811456890568621245488786207606126378186849256672911528321296805719160077610311074581188177088579868018326083037138888322611947137332175998980425940972198993710276326517939581761005458033844442257758782753862276807988223656608494432706910858441922624808737287665685365036631832879887
spoils = 6958577080737015383842052546677663483123254523492029061157843722591519052391530548381882964112818453721288987706430599735644767409527106716806113063321623

# facs = factor(e * spoils - 1)
# print("Find the factors:", e * spoils - 1)
# exit()

primary_facs = [2, 14933026852721660328827221390105361804878742609046147929131104232925577512240427089556097708165979176863297818798531753456202854345860374251]
secondary_facs = [3, 5, 5, 67, 101, 311, 347, 13399, 20807]

for subset in all_subsets(secondary_facs):
    p = prod(subset) * prod(primary_facs) + 1
    if n % p == 0:
        q = n // p
        d = pow(e, -1, (p-1)*(q-1))
        print(long_to_bytes(pow(c, d, n)))
        break